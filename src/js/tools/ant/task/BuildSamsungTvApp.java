package js.tools.ant.task;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import js.tools.ant.util.Log;
import js.tools.ant.util.Utils;
import js.tools.commons.util.Files;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;

/**
 * Build Samsung TV application archive from static resources. This task is designed to be used with
 * {@link BuildResources}; files generated by build resources task are directly usable by this task.
 * <table border="1" style="border-collapse:collapse;">
 * <tr>
 * <td>Attribute
 * <td>Description
 * <td>Required
 * <tr>
 * <td><b>app</b>
 * <td>Application name used to generate Samsung specific archive name.
 * <td>Yes
 * <tr>
 * <td><b>version</b>
 * <td>Optional version number used to generate Samsung specific archive name and to update archive config descriptor.
 * Default to 1.
 * <td>No
 * <tr>
 * <td><b>buildNumber</b>
 * <td>Build number managed by <code>buildnumber</code> Ant built-in task. <code>BuildSamsungTv</code> task uses build
 * number to generate version part from Samsung specific archive name.
 * <td>Yes
 * <tr>
 * <td><b>context</b>
 * <td>Context directory is where source files reside. Default to <code>build/context</code>.
 * <td>No
 * <tr>
 * <td><b>config</b>
 * <td>Config directory holding Samsung specific files to be integrated into archive. Default to
 * <code>config/samsung-tv</code>.
 * <td>No
 * <tr>
 * <td><b>dir</b>
 * <td>Build directory where archive is to be created. Default to <code>build</code>.
 * <td>No
 * </table>
 * 
 * <p>
 * Standard usage of this task is as follow:
 * 
 * <pre>
 *  &lt;target name="build-samsung-tv"&gt;
 *      &lt;buildnumber /&gt;
 *      &lt;js.buildResources context="build/context" buildNumber="${build.number}" /&gt;
 *      &lt;js.buildSamsungTv app="${APP-NAME}" buildNumber="${build.number}" context="build/context" config="build/config" dir="build" /&gt;
 *  &lt;/target&gt;
 * </pre>
 * 
 * @author Iulian Rotaru
 * @since 1.0
 */
public class BuildSamsungTvApp extends Task
{
  private static final String ARCHIVE_PATH_ANT_PROPERTY = "SAMSUNG-TV-ARCHIVE";
  private static final Charset CHARSET = Charset.forName("UTF-8");
  private static final int VERSION_NUMBER = 1;
  private static final String CONTEXT_DIR = "build/context";
  private static final String CONFIG_DIR = "config/samsung-tv";
  private static final String BUILD_DIR = "build";

  private static final List<String> SAMSUNG_SCRIPTS = new ArrayList<String>();
  static {
    // SAMSUNG_SCRIPTS.add("<script src=\"$MANAGER_WIDGET/Common/API/Widget.js\" type=\"text/javascript\"></script>");
    // SAMSUNG_SCRIPTS.add("<script src=\"$MANAGER_WIDGET/Common/API/TVKeyValue.js\" type=\"text/javascript\"></script>");
    // SAMSUNG_SCRIPTS.add("<script src=\"$MANAGER_WIDGET/Common/API/Plugin.js\" type=\"text/javascript\"></script>");
  }

  private String appName;
  private int versionNumber = VERSION_NUMBER;
  private int buildNumber;
  private String contextDir = CONTEXT_DIR;
  private String configPath = CONFIG_DIR;
  private String buildDir = BUILD_DIR;

  public void setApp(String appName)
  {
    this.appName = appName.replace('-', '_');
  }

  public void setVersion(int versionNumber)
  {
    this.versionNumber = versionNumber;
  }

  public void setBuildNumber(int buildNumber)
  {
    this.buildNumber = buildNumber;
  }

  public void setContext(String contextDir)
  {
    this.contextDir = contextDir;
  }

  public void setConfig(String configPath)
  {
    this.configPath = configPath;
  }

  public void setDir(String buildDir)
  {
    this.buildDir = buildDir;
  }

  private Log log;
  private File archiveFile;

  @Override
  public void execute() throws BuildException
  {
    if(this.appName == null) {
      Utils.badArgument(this, "Application name is mandatory. Please set <app> attribute.");
    }

    Project project = getProject();
    this.log = new Log(project, BuildSamsungTvApp.class);

    // project can be null only on tests
    File projectDir = project != null ? project.getBaseDir() : new File(".");
    File buildDir = new File(projectDir, this.buildDir);
    File sourceDir = new File(projectDir, this.contextDir);
    File indexFile = new File(sourceDir, "index.htm");
    if(!indexFile.exists()) {
      throw new BuildException(String.format("Invalid context directory |%s|. Missing index.htm file.", sourceDir));
    }
    File configDir = new File(projectDir, this.configPath);

    String version = version(this.versionNumber, this.buildNumber);
    updateConfigXmlVersion(configDir, version);
    String archiveName = String.format("%1$s_%2$s_Europe_%3$tY%3$tm%3$td.zip", this.appName, version, new Date());
    this.archiveFile = new File(buildDir, archiveName);

    File archiveRelativePath = new File(this.buildDir);
    archiveRelativePath = new File(archiveRelativePath, archiveName);
    if(project != null) {
      project.setNewProperty(ARCHIVE_PATH_ANT_PROPERTY, archiveRelativePath.getPath());
    }

    ZipOutputStream archive = null;
    try {
      archive = new ZipOutputStream(new FileOutputStream(this.archiveFile), CHARSET);
      addFileToArchive(configDir, configDir, archive);
      addFileToArchive(sourceDir, sourceDir, archive);
    }
    catch(IOException e) {
      throw new BuildException(e);
    }
    finally {
      Files.close(archive);
    }
  }

  private void addFileToArchive(File baseDir, File file, ZipOutputStream archive) throws IOException
  {
    if(file.isDirectory()) {
      File[] files = file.listFiles();
      if(files == null) {
        return;
      }
      for(File childFile : files) {
        addFileToArchive(baseDir, childFile, archive);
      }
      return;
    }

    // here we have a peculiar condition but could happen and need to handle it:
    // if target directory is configured to be the same as config or context directories is possible to invoke this
    // method with file parameter equals with target archive file; this recursive append of itself leads to deadlock
    if(file.equals(this.archiveFile)) {
      this.log.debug("Ignore attempt to recursivelly append archive file to itself. This can happend when target directory is the same with context or config.");
      return;
    }

    // next section performs the actual transfer of the file content to archive

    boolean htmlFile = Files.getExtension(file).equals("htm");

    String zipEntryName = file.getAbsolutePath().substring(baseDir.getAbsolutePath().length() + 1);
    if(htmlFile) {
      // j(s)-app uses .htm extension while samsung tv .html
      zipEntryName += "l";
    }

    assert this.log != null;
    this.log.debug("process file: |%s|", zipEntryName);
    archive.putNextEntry(new ZipEntry(zipEntryName));

    if(htmlFile) {
      BufferedReader fileReader = new BufferedReader(new FileReader(file));
      try {
        String line;
        boolean scriptsInjected = false;
        while((line = fileReader.readLine()) != null) {
          if(!scriptsInjected && line.startsWith("<s")) {
            for(String script : SAMSUNG_SCRIPTS) {
              archive.write(script.getBytes("UTF-8"));
              archive.write("\r\n".getBytes("UTF-8"));
            }
            scriptsInjected = true;
          }
          archive.write(line.getBytes("UTF-8"));
          archive.write("\r\n".getBytes("UTF-8"));
        }
      }
      finally {
        fileReader.close();
      }
      return;
    }

    FileInputStream fileStream = new FileInputStream(file);
    try {
      byte[] buf = new byte[1024];
      int len;
      while((len = fileStream.read(buf)) > 0) {
        archive.write(buf, 0, len);
      }
    }
    finally {
      fileStream.close();
    }
  }

  private static void updateConfigXmlVersion(File configDir, String version)
  {
//    Writer writer = null;
//    try {
//      File configFile = new File(configDir, "config.xml");
//      DocumentBuilder builder = Classes.loadService(DocumentBuilder.class);
//      Document doc = builder.loadXML(configFile);
//
//      doc.getByTag("ver").setText(version);
//
//      writer = new FileWriter(configFile);
//      doc.serialize(writer);
//    }
//    catch(FileNotFoundException e) {
//      throw new BuildException(e);
//    }
//    catch(IOException e) {
//      throw new BuildException(e);
//    }
//    finally {
//      Files.close(writer);
//    }
  }

  private static String version(int versionNumber, int buildNumber)
  {
    return String.format("%d.%03d", versionNumber, buildNumber);
  }
}
